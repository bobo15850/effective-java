/**
 * 对于所有对象都通用的方法
 */
/**
 * @author 张波波
 *
 */
package chapter03;

//八.覆盖equals时要遵守通用约定
//1.覆盖情形：如果类具有自己特有的“逻辑想等”概念（不同于对象等同），而且父类还没有覆盖equals已实现期望的行为。
//2.覆盖的作用：实现逻辑相等的判断，使得类的实例可以被用来做映射表的键（key>map）.或者作为集合的元素（set）使得映射和集合表现出预期的行为
//3.有些值类无需覆盖equals方法：即为受控实例，枚举类型，单例模式的类等。
//4.覆盖equals方法是遵守的约定:
/*
 * A.自反性 B.对称性 C.传递性 D.一致性 E.对于任何非空的引用值x,x.equals（null）必须返回false
 */
//编写高质量equals方法的诀窍：
/*
 * 1.使用==操作符检查“参数是否为这个对象的引用”，这是一种性能优化，如果比较操作代价高的时候很值得这么做
 * 2.使用instanceof操作符检查“参数是否为正确的类型(可以是接口)”
 * 3.把参数转化为正确的类型，转化之前要使用instanceof方法测试
 * 4.对于该类中的每个“关键域”，检查参数中的域是否与该对象对应的域相匹配/
 * 如果instanceof的类型是接口就要通过借口方法访问参数中的域/
 * 对于既不是float也不是double的基本类型可以用==进行比较
 * 对于引用对象域可以递归的调用equals方法比较
 * 对于float和double可以使用Float.compare和Double.compare
 * 对于数组元素要每个元素应用这些原则
 * 对于包含合法null的对象域可以：(field == o.field || (field !=null && field.equals(o.field)))
 * 域的比较顺序可能会影响到equals方法性能，应最先比较可能不一致的域。或者开销最低的域，最好是两者同时满足
 */
// 5.编写完成后要测试是否满足传递性，对称性，一致性（自反性和飞空性一般自动满足）
/*
 * 忠告：覆盖equals方法总要覆盖hashCode
 * 不要企图让equals方法过于智能
 * 不要将equals方法中声名的object参数替换为其他类型
 */

//九.覆盖equals时总要覆盖hashCode
// 1.hashCode的规范：
/*
 * A.只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象调用多次，hashCode方法都必须返回同一个整数，同一个应用程序执行多次是，每次执行可以返回不同的结果
 * B.两个对象如果根据equals对象比较是相等的，那么调用两个对象调用hashCode的返回值要相等。
 * C.如果两个对象equals方法比较结果为false，调用hashCode不一定要返回不同的结果。但是如果返回不同的结果有利于性能的提高。
 */
//2.为了提高性能可以将hashCode缓存起来，可以在类初始化的时候计算也可以延迟初始化，到hashCode第一次被调用的时候初始化
//3.计算hashCode的步骤：
/*
 * A.指定一个初始值result												float						double				long
 * B.对于对象中的每一个关键域分别计算其散列码c:按照不同类型有不同的方法，基本类型调用相关方法（Float.floatToIntBits,Double.doubleToLongBits,(int)(f^>>>32),引用类型直接递归调用hashCode方法，null>0,数组分分别求再相加）
 * C.result=result * 31 + c
 * D.返回result
 * E.测试
 */
//4.不要试图从散列码中排除掉一个对象的关键部分来提高性能，这样有可能会损失性能，造成map退化成链表

//十.始终要覆盖toString
//1.默认ToString方法的返回值为：类名+@+散列码的无符号十六进制表示
//2.toString应该返回对象包含的所有的值得关注的信息，或者摘要（对象中包含的状态信息无法用字符串表达）
//3.指定toString方法的返回格式有利有弊：指定了格式最好提供一个相匹配的静态工厂或者构造器
//4.toString返回值中包含的所有信息提供一种编程时的访问途径，而不是去解析toString字符串

//十一：谨慎覆盖clone
//1.Clone接口是对象的mixin接口,表明该对象允许克隆
//2.拷贝方法一般满足的要求：x.clone()!=x;x.clone().getClass()==x.getClass();x.clone().equal(x)
//3.如果某个类声明的域中只包含基本类型的值和指向不可变对象的引用无需再处理及未正确结果,只需要提供公有的clone方法访问途径
//4.域引用了可变对象递归的调用可变对象的clone方法：参见类A B C
//5.clone架构与引用可变对象的fianl域的正常用法不相兼容，解决方式为：从某些域中移除final
//6.特殊情况要进行深拷贝：例如hashTable_11，深拷贝的实现方式：递归、迭代
//7.克隆复杂对象最后一种方式：先调用super.clone然后把结果对象中所有的域设成空白状态，在调用高层方法重新产生对象状态，但是这种方法会有性能损失
//8.总结：所有实现了cloneable接口的类都应该用一个共有的方法覆盖clone，此公有方法首先调用super.clone，然后修正任何需要修正的域。(一般情况下意味着拷贝任何包含内部
//“深层结构”的可变对象，并用指向新对象的引用代替原来指向这些对象的引用)
/*
 * 除非是在别人的基础上扩展代码否则能不用就不用clone方法
 * 1。可用拷贝构造器或拷贝工厂代替
 * 2.建议不要使用不要使用不要使用！！！
 */

//十二：考虑实现Comparaable接口
//1.强烈建议：(x.compareto(y)==0)==(x.equals(y))
//2.该方法也要遵守自反性、对称性、传递性
//3.通常情况应返回和equals方法相同的结果，不好的情况参见BigDecinal中对hashset和treeSet调用不同的方法比较会有不同的结果 P55
// 4.如果一个域没有实现comparable接口或者需要使用一个非标准的排序关系可以使用一个显示的comparetor来代替
//5.关键域的比较顺序：从最关键的域开始，逐步进行到所有重要的域
//6.利用最差比较可能会产生溢出的问题